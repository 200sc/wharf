// Code generated by protoc-gen-go.
// source: pwr/pwr.proto
// DO NOT EDIT!

/*
Package pwr is a generated protocol buffer package.

It is generated from these files:
	pwr/pwr.proto

It has these top-level messages:
	PatchHeader
	SyncHeader
	BsdiffHeader
	SyncOp
	SignatureHeader
	BlockHash
	CompressionSettings
	ManifestHeader
	ManifestBlockHash
	WoundsHeader
	Wound
*/
package pwr

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CompressionAlgorithm int32

const (
	CompressionAlgorithm_NONE   CompressionAlgorithm = 0
	CompressionAlgorithm_BROTLI CompressionAlgorithm = 1
	CompressionAlgorithm_GZIP   CompressionAlgorithm = 2
	CompressionAlgorithm_ZSTD   CompressionAlgorithm = 3
)

var CompressionAlgorithm_name = map[int32]string{
	0: "NONE",
	1: "BROTLI",
	2: "GZIP",
	3: "ZSTD",
}
var CompressionAlgorithm_value = map[string]int32{
	"NONE":   0,
	"BROTLI": 1,
	"GZIP":   2,
	"ZSTD":   3,
}

func (x CompressionAlgorithm) String() string {
	return proto.EnumName(CompressionAlgorithm_name, int32(x))
}
func (CompressionAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type HashAlgorithm int32

const (
	HashAlgorithm_SHAKE128_32 HashAlgorithm = 0
)

var HashAlgorithm_name = map[int32]string{
	0: "SHAKE128_32",
}
var HashAlgorithm_value = map[string]int32{
	"SHAKE128_32": 0,
}

func (x HashAlgorithm) String() string {
	return proto.EnumName(HashAlgorithm_name, int32(x))
}
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type WoundKind int32

const (
	WoundKind_FILE    WoundKind = 0
	WoundKind_SYMLINK WoundKind = 1
	WoundKind_DIR     WoundKind = 2
	// sent when a file portion has been verified as valid
	WoundKind_CLOSED_FILE WoundKind = 3
)

var WoundKind_name = map[int32]string{
	0: "FILE",
	1: "SYMLINK",
	2: "DIR",
	3: "CLOSED_FILE",
}
var WoundKind_value = map[string]int32{
	"FILE":        0,
	"SYMLINK":     1,
	"DIR":         2,
	"CLOSED_FILE": 3,
}

func (x WoundKind) String() string {
	return proto.EnumName(WoundKind_name, int32(x))
}
func (WoundKind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type SyncHeader_Type int32

const (
	SyncHeader_RSYNC SyncHeader_Type = 0
	// when set, bsdiffTargetIndex must be set
	SyncHeader_BSDIFF SyncHeader_Type = 1
)

var SyncHeader_Type_name = map[int32]string{
	0: "RSYNC",
	1: "BSDIFF",
}
var SyncHeader_Type_value = map[string]int32{
	"RSYNC":  0,
	"BSDIFF": 1,
}

func (x SyncHeader_Type) String() string {
	return proto.EnumName(SyncHeader_Type_name, int32(x))
}
func (SyncHeader_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type SyncOp_Type int32

const (
	SyncOp_BLOCK_RANGE    SyncOp_Type = 0
	SyncOp_DATA           SyncOp_Type = 1
	SyncOp_HEY_YOU_DID_IT SyncOp_Type = 2049
)

var SyncOp_Type_name = map[int32]string{
	0:    "BLOCK_RANGE",
	1:    "DATA",
	2049: "HEY_YOU_DID_IT",
}
var SyncOp_Type_value = map[string]int32{
	"BLOCK_RANGE":    0,
	"DATA":           1,
	"HEY_YOU_DID_IT": 2049,
}

func (x SyncOp_Type) String() string {
	return proto.EnumName(SyncOp_Type_name, int32(x))
}
func (SyncOp_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type PatchHeader struct {
	Compression *CompressionSettings `protobuf:"bytes,1,opt,name=compression" json:"compression,omitempty"`
}

func (m *PatchHeader) Reset()                    { *m = PatchHeader{} }
func (m *PatchHeader) String() string            { return proto.CompactTextString(m) }
func (*PatchHeader) ProtoMessage()               {}
func (*PatchHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PatchHeader) GetCompression() *CompressionSettings {
	if m != nil {
		return m.Compression
	}
	return nil
}

type SyncHeader struct {
	Type      SyncHeader_Type `protobuf:"varint,1,opt,name=type,enum=io.itch.wharf.pwr.SyncHeader_Type" json:"type,omitempty"`
	FileIndex int64           `protobuf:"varint,16,opt,name=fileIndex" json:"fileIndex,omitempty"`
}

func (m *SyncHeader) Reset()                    { *m = SyncHeader{} }
func (m *SyncHeader) String() string            { return proto.CompactTextString(m) }
func (*SyncHeader) ProtoMessage()               {}
func (*SyncHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SyncHeader) GetType() SyncHeader_Type {
	if m != nil {
		return m.Type
	}
	return SyncHeader_RSYNC
}

func (m *SyncHeader) GetFileIndex() int64 {
	if m != nil {
		return m.FileIndex
	}
	return 0
}

type BsdiffHeader struct {
	TargetIndex int64 `protobuf:"varint,1,opt,name=targetIndex" json:"targetIndex,omitempty"`
}

func (m *BsdiffHeader) Reset()                    { *m = BsdiffHeader{} }
func (m *BsdiffHeader) String() string            { return proto.CompactTextString(m) }
func (*BsdiffHeader) ProtoMessage()               {}
func (*BsdiffHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *BsdiffHeader) GetTargetIndex() int64 {
	if m != nil {
		return m.TargetIndex
	}
	return 0
}

type SyncOp struct {
	Type       SyncOp_Type `protobuf:"varint,1,opt,name=type,enum=io.itch.wharf.pwr.SyncOp_Type" json:"type,omitempty"`
	FileIndex  int64       `protobuf:"varint,2,opt,name=fileIndex" json:"fileIndex,omitempty"`
	BlockIndex int64       `protobuf:"varint,3,opt,name=blockIndex" json:"blockIndex,omitempty"`
	BlockSpan  int64       `protobuf:"varint,4,opt,name=blockSpan" json:"blockSpan,omitempty"`
	Data       []byte      `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *SyncOp) Reset()                    { *m = SyncOp{} }
func (m *SyncOp) String() string            { return proto.CompactTextString(m) }
func (*SyncOp) ProtoMessage()               {}
func (*SyncOp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SyncOp) GetType() SyncOp_Type {
	if m != nil {
		return m.Type
	}
	return SyncOp_BLOCK_RANGE
}

func (m *SyncOp) GetFileIndex() int64 {
	if m != nil {
		return m.FileIndex
	}
	return 0
}

func (m *SyncOp) GetBlockIndex() int64 {
	if m != nil {
		return m.BlockIndex
	}
	return 0
}

func (m *SyncOp) GetBlockSpan() int64 {
	if m != nil {
		return m.BlockSpan
	}
	return 0
}

func (m *SyncOp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SignatureHeader struct {
	Compression *CompressionSettings `protobuf:"bytes,1,opt,name=compression" json:"compression,omitempty"`
}

func (m *SignatureHeader) Reset()                    { *m = SignatureHeader{} }
func (m *SignatureHeader) String() string            { return proto.CompactTextString(m) }
func (*SignatureHeader) ProtoMessage()               {}
func (*SignatureHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SignatureHeader) GetCompression() *CompressionSettings {
	if m != nil {
		return m.Compression
	}
	return nil
}

type BlockHash struct {
	WeakHash   uint32 `protobuf:"varint,1,opt,name=weakHash" json:"weakHash,omitempty"`
	StrongHash []byte `protobuf:"bytes,2,opt,name=strongHash,proto3" json:"strongHash,omitempty"`
}

func (m *BlockHash) Reset()                    { *m = BlockHash{} }
func (m *BlockHash) String() string            { return proto.CompactTextString(m) }
func (*BlockHash) ProtoMessage()               {}
func (*BlockHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *BlockHash) GetWeakHash() uint32 {
	if m != nil {
		return m.WeakHash
	}
	return 0
}

func (m *BlockHash) GetStrongHash() []byte {
	if m != nil {
		return m.StrongHash
	}
	return nil
}

type CompressionSettings struct {
	Algorithm CompressionAlgorithm `protobuf:"varint,1,opt,name=algorithm,enum=io.itch.wharf.pwr.CompressionAlgorithm" json:"algorithm,omitempty"`
	Quality   int32                `protobuf:"varint,2,opt,name=quality" json:"quality,omitempty"`
}

func (m *CompressionSettings) Reset()                    { *m = CompressionSettings{} }
func (m *CompressionSettings) String() string            { return proto.CompactTextString(m) }
func (*CompressionSettings) ProtoMessage()               {}
func (*CompressionSettings) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *CompressionSettings) GetAlgorithm() CompressionAlgorithm {
	if m != nil {
		return m.Algorithm
	}
	return CompressionAlgorithm_NONE
}

func (m *CompressionSettings) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type ManifestHeader struct {
	Compression *CompressionSettings `protobuf:"bytes,1,opt,name=compression" json:"compression,omitempty"`
	Algorithm   HashAlgorithm        `protobuf:"varint,2,opt,name=algorithm,enum=io.itch.wharf.pwr.HashAlgorithm" json:"algorithm,omitempty"`
}

func (m *ManifestHeader) Reset()                    { *m = ManifestHeader{} }
func (m *ManifestHeader) String() string            { return proto.CompactTextString(m) }
func (*ManifestHeader) ProtoMessage()               {}
func (*ManifestHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ManifestHeader) GetCompression() *CompressionSettings {
	if m != nil {
		return m.Compression
	}
	return nil
}

func (m *ManifestHeader) GetAlgorithm() HashAlgorithm {
	if m != nil {
		return m.Algorithm
	}
	return HashAlgorithm_SHAKE128_32
}

type ManifestBlockHash struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *ManifestBlockHash) Reset()                    { *m = ManifestBlockHash{} }
func (m *ManifestBlockHash) String() string            { return proto.CompactTextString(m) }
func (*ManifestBlockHash) ProtoMessage()               {}
func (*ManifestBlockHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ManifestBlockHash) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// Wounds files format: header, container, then any
// number of Wounds
type WoundsHeader struct {
}

func (m *WoundsHeader) Reset()                    { *m = WoundsHeader{} }
func (m *WoundsHeader) String() string            { return proto.CompactTextString(m) }
func (*WoundsHeader) ProtoMessage()               {}
func (*WoundsHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// Describe a corrupted portion of a file, in [start,end)
type Wound struct {
	Index int64     `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Start int64     `protobuf:"varint,2,opt,name=start" json:"start,omitempty"`
	End   int64     `protobuf:"varint,3,opt,name=end" json:"end,omitempty"`
	Kind  WoundKind `protobuf:"varint,4,opt,name=kind,enum=io.itch.wharf.pwr.WoundKind" json:"kind,omitempty"`
}

func (m *Wound) Reset()                    { *m = Wound{} }
func (m *Wound) String() string            { return proto.CompactTextString(m) }
func (*Wound) ProtoMessage()               {}
func (*Wound) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Wound) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Wound) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Wound) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Wound) GetKind() WoundKind {
	if m != nil {
		return m.Kind
	}
	return WoundKind_FILE
}

func init() {
	proto.RegisterType((*PatchHeader)(nil), "io.itch.wharf.pwr.PatchHeader")
	proto.RegisterType((*SyncHeader)(nil), "io.itch.wharf.pwr.SyncHeader")
	proto.RegisterType((*BsdiffHeader)(nil), "io.itch.wharf.pwr.BsdiffHeader")
	proto.RegisterType((*SyncOp)(nil), "io.itch.wharf.pwr.SyncOp")
	proto.RegisterType((*SignatureHeader)(nil), "io.itch.wharf.pwr.SignatureHeader")
	proto.RegisterType((*BlockHash)(nil), "io.itch.wharf.pwr.BlockHash")
	proto.RegisterType((*CompressionSettings)(nil), "io.itch.wharf.pwr.CompressionSettings")
	proto.RegisterType((*ManifestHeader)(nil), "io.itch.wharf.pwr.ManifestHeader")
	proto.RegisterType((*ManifestBlockHash)(nil), "io.itch.wharf.pwr.ManifestBlockHash")
	proto.RegisterType((*WoundsHeader)(nil), "io.itch.wharf.pwr.WoundsHeader")
	proto.RegisterType((*Wound)(nil), "io.itch.wharf.pwr.Wound")
	proto.RegisterEnum("io.itch.wharf.pwr.CompressionAlgorithm", CompressionAlgorithm_name, CompressionAlgorithm_value)
	proto.RegisterEnum("io.itch.wharf.pwr.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
	proto.RegisterEnum("io.itch.wharf.pwr.WoundKind", WoundKind_name, WoundKind_value)
	proto.RegisterEnum("io.itch.wharf.pwr.SyncHeader_Type", SyncHeader_Type_name, SyncHeader_Type_value)
	proto.RegisterEnum("io.itch.wharf.pwr.SyncOp_Type", SyncOp_Type_name, SyncOp_Type_value)
}

func init() { proto.RegisterFile("pwr/pwr.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 644 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x54, 0x41, 0x53, 0xda, 0x40,
	0x14, 0x36, 0x24, 0xa8, 0x3c, 0x10, 0xd7, 0xd5, 0x03, 0xd3, 0xb1, 0x0e, 0x93, 0x43, 0x75, 0x3c,
	0xa4, 0x16, 0x67, 0x9c, 0x1e, 0x3a, 0x9d, 0x02, 0x41, 0xc9, 0x80, 0xc4, 0x49, 0xe8, 0x38, 0xd8,
	0x03, 0xb3, 0x92, 0x00, 0x3b, 0x62, 0x92, 0x6e, 0xd6, 0xa6, 0x1c, 0xfd, 0x1b, 0xfd, 0x7d, 0xfd,
	0x21, 0x9d, 0x5d, 0x82, 0x60, 0x8b, 0x3d, 0x79, 0x7b, 0xef, 0xed, 0xf7, 0x7d, 0xef, 0xdb, 0xb7,
	0x2f, 0x81, 0xad, 0x28, 0x61, 0xef, 0xa3, 0x84, 0x19, 0x11, 0x0b, 0x79, 0x88, 0x77, 0x68, 0x68,
	0x50, 0x3e, 0x18, 0x1b, 0xc9, 0x98, 0xb0, 0xa1, 0x11, 0x25, 0x4c, 0xbf, 0x86, 0xfc, 0x15, 0xe1,
	0x83, 0x71, 0xd3, 0x27, 0x9e, 0xcf, 0x70, 0x13, 0xf2, 0x83, 0xf0, 0x3e, 0x62, 0x7e, 0x1c, 0xd3,
	0x30, 0x28, 0x29, 0x65, 0xe5, 0x28, 0x5f, 0x79, 0x67, 0xfc, 0xc3, 0x33, 0xea, 0x0b, 0x94, 0xeb,
	0x73, 0x4e, 0x83, 0x51, 0xec, 0x2c, 0x53, 0xf5, 0x47, 0x05, 0xc0, 0x9d, 0x06, 0x83, 0x54, 0xf8,
	0x0c, 0x34, 0x3e, 0x8d, 0x7c, 0xa9, 0x58, 0xac, 0xe8, 0x2b, 0x14, 0x17, 0x60, 0xa3, 0x3b, 0x8d,
	0x7c, 0x47, 0xe2, 0xf1, 0x3e, 0xe4, 0x86, 0x74, 0xe2, 0x5b, 0x81, 0xe7, 0xff, 0x2c, 0xa1, 0xb2,
	0x72, 0xa4, 0x3a, 0x8b, 0x82, 0xfe, 0x16, 0x34, 0x81, 0xc5, 0x39, 0xc8, 0x3a, 0x6e, 0xaf, 0x53,
	0x47, 0x6b, 0x18, 0x60, 0xbd, 0xe6, 0x9a, 0xd6, 0xf9, 0x39, 0x52, 0xf4, 0x13, 0x28, 0xd4, 0x62,
	0x8f, 0x0e, 0x87, 0xa9, 0x89, 0x32, 0xe4, 0x39, 0x61, 0x23, 0x9f, 0xcf, 0xe4, 0x14, 0x29, 0xb7,
	0x5c, 0xd2, 0x7f, 0x2b, 0xb0, 0x2e, 0x8c, 0xd8, 0x11, 0xae, 0x3c, 0x73, 0x7c, 0xf0, 0x82, 0x63,
	0x3b, 0x7a, 0xd1, 0x6d, 0xe6, 0x2f, 0xb7, 0xf8, 0x00, 0xe0, 0x76, 0x12, 0x0e, 0xee, 0x66, 0xc7,
	0xaa, 0x3c, 0x5e, 0xaa, 0x08, 0xb6, 0xcc, 0xdc, 0x88, 0x04, 0x25, 0x6d, 0xc6, 0x7e, 0x2a, 0x60,
	0x0c, 0x9a, 0x47, 0x38, 0x29, 0x65, 0xcb, 0xca, 0x51, 0xc1, 0x91, 0xb1, 0x7e, 0x96, 0xde, 0x7f,
	0x1b, 0xf2, 0xb5, 0xb6, 0x5d, 0x6f, 0xf5, 0x9d, 0x6a, 0xe7, 0xa2, 0x81, 0xd6, 0xf0, 0x26, 0x68,
	0x66, 0xb5, 0x5b, 0x45, 0x0a, 0xde, 0x85, 0x62, 0xb3, 0xd1, 0xeb, 0xf7, 0xec, 0xaf, 0x7d, 0xd3,
	0x32, 0xfb, 0x56, 0x17, 0x3d, 0x22, 0xfd, 0x1b, 0x6c, 0xbb, 0x74, 0x14, 0x10, 0xfe, 0xc0, 0xfc,
	0x57, 0x7f, 0xf9, 0x0b, 0xc8, 0xd5, 0x84, 0xeb, 0x26, 0x89, 0xc7, 0xf8, 0x0d, 0x6c, 0x26, 0x3e,
	0x91, 0xb1, 0xd4, 0xdc, 0x72, 0x9e, 0x72, 0x31, 0x8f, 0x98, 0xb3, 0x30, 0x18, 0xc9, 0xd3, 0x8c,
	0xbc, 0xd7, 0x52, 0x45, 0xff, 0x01, 0xbb, 0x2b, 0x9a, 0xe1, 0x06, 0xe4, 0xc8, 0x64, 0x14, 0x32,
	0xca, 0xc7, 0xf7, 0xe9, 0xeb, 0x1c, 0xfe, 0xdf, 0x67, 0x75, 0x0e, 0x77, 0x16, 0x4c, 0x5c, 0x82,
	0x8d, 0xef, 0x0f, 0x64, 0x42, 0xf9, 0x54, 0xb6, 0xce, 0x3a, 0xf3, 0x54, 0xff, 0xa5, 0x40, 0xf1,
	0x92, 0x04, 0x74, 0xe8, 0xc7, 0xfc, 0xb5, 0xa7, 0x83, 0x3f, 0x2f, 0xbb, 0xcf, 0x48, 0xf7, 0xe5,
	0x15, 0x3a, 0x62, 0x00, 0xab, 0x6c, 0xeb, 0x87, 0xb0, 0x33, 0xf7, 0xb6, 0x98, 0x32, 0x06, 0x6d,
	0x3c, 0x9f, 0x70, 0xc1, 0x91, 0xb1, 0x5e, 0x84, 0xc2, 0x75, 0xf8, 0x10, 0x78, 0xf1, 0xec, 0x0a,
	0x7a, 0x02, 0x59, 0x99, 0xe3, 0x3d, 0xc8, 0xd2, 0xa5, 0xfd, 0x9f, 0x25, 0xa2, 0x1a, 0x73, 0xc2,
	0x78, 0xba, 0xb6, 0xb3, 0x04, 0x23, 0x50, 0xfd, 0xc0, 0x4b, 0x77, 0x55, 0x84, 0xf8, 0x04, 0xb4,
	0x3b, 0x1a, 0x78, 0x72, 0x3f, 0x8b, 0x95, 0xfd, 0x15, 0xd6, 0x65, 0x97, 0x16, 0x0d, 0x3c, 0x47,
	0x22, 0x8f, 0xbf, 0xc0, 0xde, 0xaa, 0xb7, 0x10, 0x3b, 0xda, 0xb1, 0x3b, 0x8d, 0xf4, 0x9b, 0x75,
	0xec, 0x6e, 0xdb, 0x42, 0x8a, 0xa8, 0x5e, 0xdc, 0x58, 0x57, 0x28, 0x23, 0xa2, 0x1b, 0xb7, 0x6b,
	0x22, 0xf5, 0xb8, 0x0c, 0x5b, 0xcf, 0xe6, 0x21, 0xf6, 0xdd, 0x6d, 0x56, 0x5b, 0x8d, 0x0f, 0x95,
	0x8f, 0xfd, 0xd3, 0x0a, 0x5a, 0x3b, 0xfe, 0x04, 0xb9, 0xa7, 0xb6, 0x82, 0x78, 0x6e, 0xb5, 0x85,
	0x70, 0x1e, 0x36, 0xdc, 0xde, 0x65, 0xdb, 0xea, 0xb4, 0x90, 0x82, 0x37, 0x40, 0x35, 0x2d, 0x07,
	0x65, 0x04, 0xbb, 0xde, 0xb6, 0xdd, 0x86, 0xd9, 0x97, 0x30, 0xb5, 0x96, 0xbd, 0x51, 0xa3, 0x84,
	0xdd, 0xae, 0xcb, 0xbf, 0xe4, 0xe9, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6d, 0x1f, 0x29, 0x01,
	0x36, 0x05, 0x00, 0x00,
}
