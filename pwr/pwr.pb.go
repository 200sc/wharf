// Code generated by protoc-gen-go.
// source: pwr/pwr.proto
// DO NOT EDIT!

/*
Package pwr is a generated protocol buffer package.

It is generated from these files:
	pwr/pwr.proto

It has these top-level messages:
	PatchHeader
	SyncHeader
	SyncOp
	SignatureHeader
	BlockHash
	CompressionSettings
	ManifestHeader
	ManifestBlockHash
*/
package pwr

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type CompressionAlgorithm int32

const (
	CompressionAlgorithm_NONE   CompressionAlgorithm = 0
	CompressionAlgorithm_BROTLI CompressionAlgorithm = 1
	CompressionAlgorithm_GZIP   CompressionAlgorithm = 2
)

var CompressionAlgorithm_name = map[int32]string{
	0: "NONE",
	1: "BROTLI",
	2: "GZIP",
}
var CompressionAlgorithm_value = map[string]int32{
	"NONE":   0,
	"BROTLI": 1,
	"GZIP":   2,
}

func (x CompressionAlgorithm) String() string {
	return proto.EnumName(CompressionAlgorithm_name, int32(x))
}
func (CompressionAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type HashAlgorithm int32

const (
	HashAlgorithm_SHAKE128_32 HashAlgorithm = 0
)

var HashAlgorithm_name = map[int32]string{
	0: "SHAKE128_32",
}
var HashAlgorithm_value = map[string]int32{
	"SHAKE128_32": 0,
}

func (x HashAlgorithm) String() string {
	return proto.EnumName(HashAlgorithm_name, int32(x))
}
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type SyncOp_Type int32

const (
	SyncOp_BLOCK_RANGE SyncOp_Type = 0
	SyncOp_DATA        SyncOp_Type = 1
	// REMOTE_DATA used to be 2 - shouldn't be in the wild, but better not re-use it?
	SyncOp_HEY_YOU_DID_IT SyncOp_Type = 2049
)

var SyncOp_Type_name = map[int32]string{
	0:    "BLOCK_RANGE",
	1:    "DATA",
	2049: "HEY_YOU_DID_IT",
}
var SyncOp_Type_value = map[string]int32{
	"BLOCK_RANGE":    0,
	"DATA":           1,
	"HEY_YOU_DID_IT": 2049,
}

func (x SyncOp_Type) String() string {
	return proto.EnumName(SyncOp_Type_name, int32(x))
}
func (SyncOp_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type PatchHeader struct {
	Compression *CompressionSettings `protobuf:"bytes,1,opt,name=compression" json:"compression,omitempty"`
}

func (m *PatchHeader) Reset()                    { *m = PatchHeader{} }
func (m *PatchHeader) String() string            { return proto.CompactTextString(m) }
func (*PatchHeader) ProtoMessage()               {}
func (*PatchHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PatchHeader) GetCompression() *CompressionSettings {
	if m != nil {
		return m.Compression
	}
	return nil
}

type SyncHeader struct {
	FileIndex int64 `protobuf:"varint,16,opt,name=fileIndex" json:"fileIndex,omitempty"`
}

func (m *SyncHeader) Reset()                    { *m = SyncHeader{} }
func (m *SyncHeader) String() string            { return proto.CompactTextString(m) }
func (*SyncHeader) ProtoMessage()               {}
func (*SyncHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type SyncOp struct {
	Type       SyncOp_Type `protobuf:"varint,1,opt,name=type,enum=io.itch.wharf.pwr.SyncOp_Type" json:"type,omitempty"`
	FileIndex  int64       `protobuf:"varint,2,opt,name=fileIndex" json:"fileIndex,omitempty"`
	BlockIndex int64       `protobuf:"varint,3,opt,name=blockIndex" json:"blockIndex,omitempty"`
	BlockSpan  int64       `protobuf:"varint,4,opt,name=blockSpan" json:"blockSpan,omitempty"`
	Data       []byte      `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *SyncOp) Reset()                    { *m = SyncOp{} }
func (m *SyncOp) String() string            { return proto.CompactTextString(m) }
func (*SyncOp) ProtoMessage()               {}
func (*SyncOp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type SignatureHeader struct {
	Compression *CompressionSettings `protobuf:"bytes,1,opt,name=compression" json:"compression,omitempty"`
}

func (m *SignatureHeader) Reset()                    { *m = SignatureHeader{} }
func (m *SignatureHeader) String() string            { return proto.CompactTextString(m) }
func (*SignatureHeader) ProtoMessage()               {}
func (*SignatureHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SignatureHeader) GetCompression() *CompressionSettings {
	if m != nil {
		return m.Compression
	}
	return nil
}

type BlockHash struct {
	WeakHash   uint32 `protobuf:"varint,1,opt,name=weakHash" json:"weakHash,omitempty"`
	StrongHash []byte `protobuf:"bytes,2,opt,name=strongHash,proto3" json:"strongHash,omitempty"`
}

func (m *BlockHash) Reset()                    { *m = BlockHash{} }
func (m *BlockHash) String() string            { return proto.CompactTextString(m) }
func (*BlockHash) ProtoMessage()               {}
func (*BlockHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type CompressionSettings struct {
	Algorithm CompressionAlgorithm `protobuf:"varint,1,opt,name=algorithm,enum=io.itch.wharf.pwr.CompressionAlgorithm" json:"algorithm,omitempty"`
	Quality   int32                `protobuf:"varint,2,opt,name=quality" json:"quality,omitempty"`
}

func (m *CompressionSettings) Reset()                    { *m = CompressionSettings{} }
func (m *CompressionSettings) String() string            { return proto.CompactTextString(m) }
func (*CompressionSettings) ProtoMessage()               {}
func (*CompressionSettings) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type ManifestHeader struct {
	Compression *CompressionSettings `protobuf:"bytes,1,opt,name=compression" json:"compression,omitempty"`
	Algorithm   HashAlgorithm        `protobuf:"varint,2,opt,name=algorithm,enum=io.itch.wharf.pwr.HashAlgorithm" json:"algorithm,omitempty"`
}

func (m *ManifestHeader) Reset()                    { *m = ManifestHeader{} }
func (m *ManifestHeader) String() string            { return proto.CompactTextString(m) }
func (*ManifestHeader) ProtoMessage()               {}
func (*ManifestHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ManifestHeader) GetCompression() *CompressionSettings {
	if m != nil {
		return m.Compression
	}
	return nil
}

type ManifestBlockHash struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *ManifestBlockHash) Reset()                    { *m = ManifestBlockHash{} }
func (m *ManifestBlockHash) String() string            { return proto.CompactTextString(m) }
func (*ManifestBlockHash) ProtoMessage()               {}
func (*ManifestBlockHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func init() {
	proto.RegisterType((*PatchHeader)(nil), "io.itch.wharf.pwr.PatchHeader")
	proto.RegisterType((*SyncHeader)(nil), "io.itch.wharf.pwr.SyncHeader")
	proto.RegisterType((*SyncOp)(nil), "io.itch.wharf.pwr.SyncOp")
	proto.RegisterType((*SignatureHeader)(nil), "io.itch.wharf.pwr.SignatureHeader")
	proto.RegisterType((*BlockHash)(nil), "io.itch.wharf.pwr.BlockHash")
	proto.RegisterType((*CompressionSettings)(nil), "io.itch.wharf.pwr.CompressionSettings")
	proto.RegisterType((*ManifestHeader)(nil), "io.itch.wharf.pwr.ManifestHeader")
	proto.RegisterType((*ManifestBlockHash)(nil), "io.itch.wharf.pwr.ManifestBlockHash")
	proto.RegisterEnum("io.itch.wharf.pwr.CompressionAlgorithm", CompressionAlgorithm_name, CompressionAlgorithm_value)
	proto.RegisterEnum("io.itch.wharf.pwr.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
	proto.RegisterEnum("io.itch.wharf.pwr.SyncOp_Type", SyncOp_Type_name, SyncOp_Type_value)
}

var fileDescriptor0 = []byte{
	// 483 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x53, 0x4f, 0x6f, 0xd3, 0x30,
	0x1c, 0x5d, 0xba, 0xb4, 0xac, 0xbf, 0xd2, 0x2e, 0xf3, 0x38, 0x44, 0x08, 0x4d, 0x55, 0x0e, 0x0c,
	0xf5, 0x10, 0x44, 0x26, 0x4d, 0x9c, 0x90, 0xd2, 0xb5, 0x6a, 0xa2, 0x8d, 0x66, 0x72, 0x8a, 0xd0,
	0xc6, 0x21, 0xf2, 0x5a, 0xb7, 0xb1, 0xe8, 0x92, 0x90, 0x78, 0x94, 0x1e, 0xf9, 0x1a, 0x7c, 0x3e,
	0x3e, 0x08, 0xb6, 0xbb, 0xae, 0x1d, 0x44, 0x9c, 0x76, 0x88, 0x64, 0xff, 0xfe, 0xbc, 0xf7, 0xf2,
	0xf2, 0x02, 0xcd, 0x6c, 0x91, 0xbf, 0x15, 0x8f, 0x9d, 0xe5, 0x29, 0x4f, 0xd1, 0x01, 0x4b, 0x6d,
	0xc6, 0xc7, 0xb1, 0xbd, 0x88, 0x49, 0x3e, 0xb5, 0x45, 0xc3, 0xfa, 0x0c, 0x8d, 0x4b, 0x22, 0x4a,
	0x1e, 0x25, 0x13, 0x9a, 0x23, 0x0f, 0x1a, 0xe3, 0xf4, 0x36, 0xcb, 0x69, 0x51, 0xb0, 0x34, 0x31,
	0xb5, 0xb6, 0xf6, 0xa6, 0xe1, 0xbc, 0xb6, 0xff, 0xd9, 0xb3, 0xcf, 0x36, 0x53, 0x21, 0xe5, 0x9c,
	0x25, 0xb3, 0x02, 0x6f, 0xaf, 0x5a, 0x1d, 0x80, 0x70, 0x99, 0x8c, 0xef, 0x71, 0x5f, 0x41, 0x7d,
	0xca, 0xe6, 0xd4, 0x4f, 0x26, 0xf4, 0x87, 0x69, 0x08, 0xd4, 0x5d, 0xbc, 0x29, 0x58, 0xbf, 0x35,
	0xa8, 0xc9, 0xe1, 0x20, 0x43, 0x0e, 0xe8, 0x7c, 0x99, 0x51, 0xc5, 0xdc, 0x72, 0x8e, 0x4a, 0x98,
	0x57, 0x83, 0xf6, 0x48, 0x4c, 0x61, 0x35, 0xfb, 0x18, 0xbc, 0xf2, 0x17, 0x38, 0x3a, 0x02, 0xb8,
	0x99, 0xa7, 0xe3, 0xaf, 0xab, 0xf6, 0xae, 0x6a, 0x6f, 0x55, 0xe4, 0xb6, 0xba, 0x85, 0x19, 0x49,
	0x4c, 0x7d, 0xb5, 0xfd, 0x50, 0x40, 0x08, 0xf4, 0x09, 0xe1, 0xc4, 0xac, 0x8a, 0xc6, 0x73, 0xac,
	0xce, 0xd6, 0x29, 0xe8, 0x92, 0x1d, 0xed, 0x43, 0xa3, 0x7b, 0x11, 0x9c, 0x9d, 0x47, 0xd8, 0x1d,
	0x0e, 0xfa, 0xc6, 0x0e, 0xda, 0x03, 0xbd, 0xe7, 0x8e, 0x5c, 0x43, 0x43, 0x87, 0xd0, 0xf2, 0xfa,
	0x57, 0xd1, 0x55, 0xf0, 0x29, 0xea, 0xf9, 0xbd, 0xc8, 0x1f, 0x19, 0x3f, 0x0d, 0xeb, 0x0b, 0xec,
	0x87, 0x6c, 0x96, 0x10, 0x7e, 0x97, 0xd3, 0x27, 0xf7, 0x7b, 0x00, 0xf5, 0xae, 0x54, 0xed, 0x91,
	0x22, 0x46, 0x2f, 0x61, 0x6f, 0x41, 0x89, 0x3a, 0x2b, 0xcc, 0x26, 0x7e, 0xb8, 0x4b, 0x3f, 0x0a,
	0x9e, 0xa7, 0xc9, 0x4c, 0x75, 0x2b, 0xea, 0xbd, 0xb6, 0x2a, 0xd6, 0x77, 0x38, 0x2c, 0x21, 0x43,
	0x7d, 0xa8, 0x93, 0xf9, 0x2c, 0xcd, 0x19, 0x8f, 0x6f, 0xef, 0xbf, 0xce, 0xf1, 0xff, 0x75, 0xba,
	0xeb, 0x71, 0xbc, 0xd9, 0x44, 0x26, 0x3c, 0xfb, 0x76, 0x47, 0xe6, 0x8c, 0x2f, 0x15, 0x75, 0x15,
	0xaf, 0xaf, 0xd6, 0x2f, 0x0d, 0x5a, 0x1f, 0x49, 0xc2, 0xa6, 0xb4, 0xe0, 0x4f, 0xed, 0x0e, 0xfa,
	0xb0, 0xad, 0xbe, 0xa2, 0xd4, 0xb7, 0x4b, 0x70, 0xa4, 0x01, 0x65, 0xb2, 0xad, 0x63, 0x38, 0x58,
	0x6b, 0xdb, 0xb8, 0x2c, 0xb2, 0x11, 0xaf, 0x1d, 0x16, 0xd9, 0x90, 0xe7, 0xce, 0x29, 0xbc, 0x28,
	0xb3, 0x40, 0x46, 0x63, 0x18, 0x0c, 0x65, 0x48, 0x00, 0x6a, 0x5d, 0x1c, 0x8c, 0x2e, 0x7c, 0x11,
	0x13, 0x51, 0x1d, 0x5c, 0xfb, 0x97, 0x46, 0xa5, 0xd3, 0x86, 0xe6, 0x23, 0x72, 0x19, 0xae, 0xd0,
	0x73, 0xcf, 0xfb, 0xef, 0x9c, 0xf7, 0xd1, 0x89, 0x63, 0xec, 0x74, 0xab, 0xd7, 0xbb, 0x42, 0xe2,
	0x4d, 0x4d, 0xfd, 0xca, 0x27, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x48, 0x68, 0x26, 0xef, 0xdb,
	0x03, 0x00, 0x00,
}
